import { NextRequest, NextResponse } from 'next/server';
import prisma from '../../../../prisma/singleton';
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Helper function to add CORS headers
function addCorsHeaders(response: NextResponse) {
  response.headers.set('Access-Control-Allow-Origin', '*');
  response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  return response;
}

// Enhanced token verification
const verifyToken = (token: string) => {
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    return decoded;
  } catch (error) {
    console.error('[SET_OPERATIONS] Token verification failed:', error);
    return null;
  }
};

// Handle OPTIONS request for CORS preflight
export async function OPTIONS() {
  const response = new NextResponse(null, { status: 200 });
  return addCorsHeaders(response);
}

export async function GET(req: NextRequest, { params }: { params: { set_id: string } }) {
  const { set_id } = params;
  const token = req.headers.get('authorization')?.split(' ')[1];
  const decoded = token ? verifyToken(token) : null;
  
  if (!decoded) {
    console.error('[GET /api/set/[set_id]] Error: Unauthorized');
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    console.log('[GET /api/set/[set_id]] Fetching set:', set_id, 'for user_id:', (decoded as any).user_id);
    // Find the set, including user and cards
    const set = await prisma.set.findUnique({
      where: { set_id },
      include: {
        cards: true,
        user: { select: { full_name: true, user_id: true } },
      },
    });
    if (!set) {
      console.error('[GET /api/set/[set_id]] Error: Set not found', { set_id });
      return NextResponse.json({ error: 'Set not found' }, { status: 404 });
    }
    // Allow if user is owner
    if (set.user_id === (decoded as any).user_id) {
      console.log('[GET /api/set/[set_id]] Returning set for owner:', JSON.stringify({ set_id: set.set_id, cards: set.cards }, null, 2));
      return NextResponse.json(set);
    }
    // Allow if set is posted
    if (set.posted === true) {
      console.log('[GET /api/set/[set_id]] Returning posted set:', JSON.stringify({ set_id: set.set_id, cards: set.cards }, null, 2));
      return NextResponse.json(set);
    }
    // Allow if user is a friend of the owner (using _Friends join table)
    const isFriend = await prisma._Friends.findFirst({
      where: {
        OR: [
          { A: set.user_id, B: (decoded as any).user_id },
          { A: (decoded as any).user_id, B: set.user_id },
        ],
      },
    });
    if (isFriend) {
      console.log('[GET /api/set/[set_id]] Returning set for friend:', JSON.stringify({ set_id: set.set_id, cards: set.cards }, null, 2));
      return NextResponse.json(set);
    }
    // Otherwise, unauthorized
    console.error('[GET /api/set/[set_id]] Error: Set not found or unauthorized', { set_id, user_id: (decoded as any).user_id });
    return NextResponse.json({ error: 'Set not found or unauthorized' }, { status: 404 });
  } catch (error) {
    console.error('[GET /api/set/[set_id]] Error:', error);
    return NextResponse.json({ error: 'Failed to fetch set' }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}

/**
 * Updates a draft set (PUT /api/set/[set_id])
 */
export async function PUT(req: NextRequest, { params }: { params: { set_id: string } }) {
  const { set_id } = params;
  const token = req.headers.get('authorization')?.split(' ')[1];
  const decoded = token ? verifyToken(token) : null;
  
  if (!decoded) {
    console.error('[PUT /api/set/[set_id]] Error: Unauthorized');
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await req.json();
    const { set_name, set_subject, description, cards } = body;
    
    console.log('[PUT /api/set/[set_id]] Updating set:', set_id, 'for user_id:', (decoded as any).user_id);

    // Check if set exists and user owns it
    const existingSet = await prisma.set.findUnique({
      where: { set_id },
      include: { cards: true }
    });

    if (!existingSet) {
      return NextResponse.json({ error: 'Set not found' }, { status: 404 });
    }

    if (existingSet.user_id !== (decoded as any).user_id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
    }

    // Only allow updates to draft sets
    if (existingSet.status === 'published') {
      return NextResponse.json({ error: 'Cannot update published set' }, { status: 400 });
    }

    // Update set data
    const updateData: any = {};
    if (set_name) updateData.set_name = set_name.trim();
    if (set_subject) updateData.set_subject = set_subject.trim();
    if (description !== undefined) updateData.description = description ? String(description).slice(0, 30) : null;

    const updatedSet = await prisma.set.update({
      where: { set_id },
      data: updateData,
      include: { cards: true }
    });

    // Update cards if provided
    if (Array.isArray(cards)) {
      // Delete existing cards
      await prisma.card.deleteMany({
        where: { set_id }
      });

      // Create new cards
      const allowedColors = ['yellow', 'blue', 'green', 'pink', 'white', 'lightblue', 'lightgreen', 'purple', 'red', 'brown'];
      for (const card of cards) {
        if (card.card_question && card.card_answer) {
          const color = allowedColors.includes(card.color) ? card.color : 'yellow';
          await prisma.card.create({
            data: {
              set_id,
              card_question: card.card_question,
              card_answer: card.card_answer,
              color,
            }
          });
        }
      }

      // Update card count
      await prisma.set.update({
        where: { set_id },
        data: { number_of_cards: cards.filter(c => c.card_question && c.card_answer).length }
      });
    }

    // Fetch updated set with cards
    const finalSet = await prisma.set.findUnique({
      where: { set_id },
      include: { cards: true }
    });

    console.log('[PUT /api/set/[set_id]] Set updated successfully:', set_id);
    return NextResponse.json({ 
      message: 'Draft updated successfully',
      set: finalSet
    });

  } catch (error) {
    console.error('[PUT /api/set/[set_id]] Error:', error);
    return NextResponse.json({ error: 'Failed to update set' }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
} 